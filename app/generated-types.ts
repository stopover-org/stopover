import { useQuery, UseQueryOptions, useMutation, UseMutationOptions } from 'react-query';
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };

function fetcher<TData, TVariables>(endpoint: string, requestInit: RequestInit, query: string, variables?: TVariables) {
  return async (): Promise<TData> => {
    const res = await fetch(endpoint, {
      method: 'POST',
      ...requestInit,
      body: JSON.stringify({ query, variables }),
    });

    const json = await res.json();

    if (json.errors) {
      const { message } = json.errors[0];

      throw new Error(message);
    }

    return json.data;
  }
}
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
};

export type Query = {
  __typename?: 'Query';
  currentUser?: Maybe<User>;
  interests?: Maybe<Array<Interest>>;
};


export type QueryInterestsArgs = {
  filters?: InputMaybe<InterestsFilter>;
};

export type User = {
  __typename?: 'User';
  account: Account;
  email?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  phone?: Maybe<Scalars['String']>;
  relayId: Scalars['ID'];
};

export type Account = {
  __typename?: 'Account';
  city?: Maybe<Scalars['String']>;
  country?: Maybe<Scalars['String']>;
  fullAddress?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  interests?: Maybe<Array<Interest>>;
  latitude?: Maybe<Scalars['Float']>;
  longitude?: Maybe<Scalars['Float']>;
  name?: Maybe<Scalars['String']>;
  phone?: Maybe<Array<Scalars['String']>>;
  primaryPhone?: Maybe<Scalars['String']>;
  region?: Maybe<Scalars['String']>;
  relayId: Scalars['ID'];
  status: Scalars['String'];
  street?: Maybe<Scalars['String']>;
  verifiedAt?: Maybe<Scalars['String']>;
};

export type Interest = {
  __typename?: 'Interest';
  id?: Maybe<Scalars['ID']>;
  preview?: Maybe<Scalars['String']>;
  relayId: Scalars['ID'];
  slug?: Maybe<Scalars['String']>;
  title?: Maybe<Scalars['String']>;
};

export type InterestsFilter = {
  query?: InputMaybe<Scalars['String']>;
};

export type Mutation = {
  __typename?: 'Mutation';
  createEvent?: Maybe<CreateEventPayload>;
  setUpAccount?: Maybe<SetUpAccountPayload>;
  signIn?: Maybe<SignInPayload>;
};


export type MutationCreateEventArgs = {
  input: CreateEventInput;
};


export type MutationSetUpAccountArgs = {
  input: SetUpAccountInput;
};


export type MutationSignInArgs = {
  input: SignInInput;
};

/** Autogenerated input type of CreateEvent */
export type CreateEventInput = {
  city?: InputMaybe<Scalars['String']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  country?: InputMaybe<Scalars['String']>;
  dates?: InputMaybe<Array<Scalars['String']>>;
  description?: InputMaybe<Scalars['String']>;
  durationTime?: InputMaybe<Scalars['Int']>;
  eventOptions?: InputMaybe<Array<CreateEventOptionInput>>;
  eventType?: InputMaybe<EventTypeEnum>;
  fullAddress: Scalars['String'];
  houseNumber?: InputMaybe<Scalars['String']>;
  interestIds?: InputMaybe<Array<Scalars['ID']>>;
  latitude?: InputMaybe<Scalars['Float']>;
  longitude?: InputMaybe<Scalars['Float']>;
  organizerCostPerUomCents?: InputMaybe<Scalars['Int']>;
  recurringType?: InputMaybe<RecurringTypeEnum>;
  region?: InputMaybe<Scalars['String']>;
  requiresCheckIn?: InputMaybe<Scalars['Boolean']>;
  requiresContract?: InputMaybe<Scalars['Boolean']>;
  requiresPassport?: InputMaybe<Scalars['Boolean']>;
  street?: InputMaybe<Scalars['String']>;
  title: Scalars['String'];
  unitId?: InputMaybe<Scalars['ID']>;
};

export type CreateEventOptionInput = {
  builtIn: Scalars['Boolean'];
  organizerCostCents: Scalars['Int'];
  title: Scalars['String'];
};

export enum EventTypeEnum {
  /** type for incity excursion with guide */
  Excursion = 'excursion',
  /** type for offroad tour */
  Tour = 'tour'
}

export enum RecurringTypeEnum {
  /** uses for non recurring type of events */
  General = 'general',
  /** uses for recurring events */
  Recurrent = 'recurrent'
}

/** Autogenerated return type of CreateEvent */
export type CreateEventPayload = {
  __typename?: 'CreateEventPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  event?: Maybe<Event>;
};

export type Event = {
  __typename?: 'Event';
  achievements?: Maybe<Array<Achievement>>;
  attendeeCostPerUomCents?: Maybe<Scalars['Int']>;
  city?: Maybe<Scalars['String']>;
  country?: Maybe<Scalars['String']>;
  description?: Maybe<Scalars['String']>;
  durationTime?: Maybe<Scalars['String']>;
  eventOptions?: Maybe<Array<EventOption>>;
  eventType?: Maybe<EventTypeEnum>;
  fullAddress?: Maybe<Scalars['String']>;
  houseNumber?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['ID']>;
  interests?: Maybe<Array<Interest>>;
  latitude?: Maybe<Scalars['Float']>;
  longitude?: Maybe<Scalars['Float']>;
  organizerCostPerUomCents?: Maybe<Scalars['Int']>;
  recurringDaysWithTime?: Maybe<Array<Scalars['String']>>;
  recurringType?: Maybe<RecurringTypeEnum>;
  region?: Maybe<Scalars['String']>;
  relayId: Scalars['ID'];
  requiresCheckIn?: Maybe<Scalars['Boolean']>;
  requiresContract?: Maybe<Scalars['Boolean']>;
  requiresPassport?: Maybe<Scalars['Boolean']>;
  singleDaysWithTime?: Maybe<Array<Scalars['String']>>;
  street?: Maybe<Scalars['String']>;
  title?: Maybe<Scalars['String']>;
  unit?: Maybe<Unit>;
};

export type Achievement = {
  __typename?: 'Achievement';
  preview?: Maybe<Scalars['String']>;
  relayId: Scalars['ID'];
  title?: Maybe<Scalars['String']>;
};

export type EventOption = {
  __typename?: 'EventOption';
  attendeeCostCents?: Maybe<Scalars['Int']>;
  builtIn?: Maybe<Scalars['Boolean']>;
  id?: Maybe<Scalars['ID']>;
  organizerCostCents?: Maybe<Scalars['Int']>;
  relayId: Scalars['ID'];
  title?: Maybe<Scalars['String']>;
};

export type Unit = {
  __typename?: 'Unit';
  id?: Maybe<Scalars['ID']>;
  name?: Maybe<Scalars['String']>;
  preview?: Maybe<Scalars['String']>;
  relayId: Scalars['ID'];
  unitType?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of SetUpAccount */
export type SetUpAccountInput = {
  city?: InputMaybe<Scalars['String']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  country: Scalars['String'];
  fullAddress: Scalars['String'];
  houseNumber?: InputMaybe<Scalars['String']>;
  interestIds?: InputMaybe<Array<Scalars['ID']>>;
  latitude?: InputMaybe<Scalars['Float']>;
  longitude?: InputMaybe<Scalars['Float']>;
  name: Scalars['String'];
  primaryPhone: Scalars['String'];
  region?: InputMaybe<Scalars['String']>;
  street?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of SetUpAccount */
export type SetUpAccountPayload = {
  __typename?: 'SetUpAccountPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  user?: Maybe<User>;
};

/** Autogenerated input type of SignIn */
export type SignInInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  code?: InputMaybe<Scalars['String']>;
  type: SignInTypesEnum;
  username: Scalars['String'];
};

export enum SignInTypesEnum {
  /** allowed to sign in with email */
  Email = 'email',
  /** allowed to sign in with phone */
  Phone = 'phone'
}

/** Autogenerated return type of SignIn */
export type SignInPayload = {
  __typename?: 'SignInPayload';
  accessToken?: Maybe<Scalars['String']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  delay?: Maybe<Scalars['Int']>;
  user?: Maybe<User>;
};

export type CurrentUserQueryQueryVariables = Exact<{ [key: string]: never; }>;


export type CurrentUserQueryQuery = { __typename?: 'Query', currentUser?: { __typename?: 'User', id: string, account: { __typename?: 'Account', id: string, name?: string | null, primaryPhone?: string | null } } | null };

export type SignInMutationMutationVariables = Exact<{
  input: SignInInput;
}>;


export type SignInMutationMutation = { __typename?: 'Mutation', signIn?: { __typename?: 'SignInPayload', delay?: number | null, accessToken?: string | null, user?: { __typename?: 'User', id: string } | null } | null };


export const CurrentUserQueryDocument = `
    query currentUserQuery {
  currentUser {
    id
    account {
      id
      name
      primaryPhone
    }
  }
}
    `;
export const useCurrentUserQueryQuery = <
      TData = CurrentUserQueryQuery,
      TError = unknown
    >(
      dataSource: { endpoint: string, fetchParams?: RequestInit },
      variables?: CurrentUserQueryQueryVariables,
      options?: UseQueryOptions<CurrentUserQueryQuery, TError, TData>
    ) =>
    useQuery<CurrentUserQueryQuery, TError, TData>(
      variables === undefined ? ['currentUserQuery'] : ['currentUserQuery', variables],
      fetcher<CurrentUserQueryQuery, CurrentUserQueryQueryVariables>(dataSource.endpoint, dataSource.fetchParams || {}, CurrentUserQueryDocument, variables),
      options
    );
export const SignInMutationDocument = `
    mutation signInMutation($input: SignInInput!) {
  signIn(input: $input) {
    user {
      id
    }
    delay
    accessToken
  }
}
    `;
export const useSignInMutationMutation = <
      TError = unknown,
      TContext = unknown
    >(
      dataSource: { endpoint: string, fetchParams?: RequestInit },
      options?: UseMutationOptions<SignInMutationMutation, TError, SignInMutationMutationVariables, TContext>
    ) =>
    useMutation<SignInMutationMutation, TError, SignInMutationMutationVariables, TContext>(
      ['signInMutation'],
      (variables?: SignInMutationMutationVariables) => fetcher<SignInMutationMutation, SignInMutationMutationVariables>(dataSource.endpoint, dataSource.fetchParams || {}, SignInMutationDocument, variables)(),
      options
    );